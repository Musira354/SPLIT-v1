{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { db } from \"../config/firebase\";\nimport { getFirestore, doc, addDoc, collection, deleteDoc, setDoc, query, getDocs, getDoc, orderBy, limit, get, where, updateDoc } from 'firebase/firestore';\nimport { getUsers } from \"../AppData\";\nvar transactionCollection = collection(db, 'transaction');\nvar groupCollection = collection(db, 'group');\nvar debtCollection = collection(db, 'debt');\nvar userCollection = collection(db, 'user');\nvar passcodeLength = 5;\nexport function GetGroupDebts(_x) {\n  return _GetGroupDebts.apply(this, arguments);\n}\nfunction _GetGroupDebts() {\n  _GetGroupDebts = _asyncToGenerator(function* (groupId) {\n    var debtList = [];\n    var q = query(debtCollection, where(\"groupId\", \"==\", groupId), orderBy(\"total\", \"desc\"));\n    var querySnapshot = yield getDocs(q);\n    querySnapshot.forEach(function () {\n      var _ref = _asyncToGenerator(function* (doc) {\n        var owerName = getUsers().find(function (user) {\n          return user.id === doc.data()['owerId'];\n        }).name;\n        var lenderName = getUsers().find(function (user) {\n          return user.id === doc.data()['lenderId'];\n        }).name;\n        debtList.push(_objectSpread(_objectSpread({}, doc.data()), {}, {\n          id: doc.id,\n          owerName: owerName,\n          lenderName: lenderName\n        }));\n      });\n      return function (_x19) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    return debtList;\n  });\n  return _GetGroupDebts.apply(this, arguments);\n}\nexport function GetGroupData(_x2) {\n  return _GetGroupData.apply(this, arguments);\n}\nfunction _GetGroupData() {\n  _GetGroupData = _asyncToGenerator(function* (groupId) {\n    var docRef = doc(groupCollection, groupId);\n    var groupData;\n    try {\n      var docSnap = yield getDoc(docRef);\n      if (docSnap.exists()) {\n        groupData = docSnap.data();\n        console.log(groupData);\n      } else {\n        console.log(\"Group does not exist\");\n      }\n    } catch (error) {\n      console.log(error);\n    }\n    return groupData;\n  });\n  return _GetGroupData.apply(this, arguments);\n}\nexport function GetGroupTransactions(_x3) {\n  return _GetGroupTransactions.apply(this, arguments);\n}\nfunction _GetGroupTransactions() {\n  _GetGroupTransactions = _asyncToGenerator(function* (groupId) {\n    var transactionList = [];\n    var q = query(transactionCollection, where(\"groupId\", \"==\", groupId));\n    var querySnapshot = yield getDocs(q);\n    querySnapshot.forEach(function (doc) {\n      console.log(doc.id, \" => \", doc.data());\n      transactionList.push(doc.data());\n    });\n    return transactionList;\n  });\n  return _GetGroupTransactions.apply(this, arguments);\n}\nexport function createTransaction(_x4, _x5, _x6, _x7, _x8) {\n  return _createTransaction.apply(this, arguments);\n}\nfunction _createTransaction() {\n  _createTransaction = _asyncToGenerator(function* (transactionName, transactionTotal, groupId, debts, currentGroupTotal) {\n    var groupRef = doc(groupCollection, groupId);\n    var newTotal = (parseFloat(currentGroupTotal) + parseFloat(transactionTotal)).toFixed(2);\n    var updatedGroupData = {\n      total: parseFloat(newTotal)\n    };\n    yield updateDoc(groupRef, updatedGroupData);\n    var data = {\n      name: transactionName,\n      total: transactionTotal,\n      groupId: groupId\n    };\n    var transaction = yield addDoc(transactionCollection, data);\n    console.log(debts);\n    var q = query(debtCollection, where(\"groupId\", \"==\", groupId));\n    var allDebts = yield getDocs(q);\n    yield Promise.all(debts.map(function () {\n      var _ref2 = _asyncToGenerator(function* (element) {\n        var found = false;\n        if (allDebts.size <= 0) {\n          console.log('Added debt');\n          var debt = yield addDoc(debtCollection, element);\n          found = true;\n        }\n        for (var x = 0; x < allDebts.size; x++) {\n          console.log(allDebts.docs[x].data());\n          if (allDebts.docs[x].data()['lenderId'] == element['lenderId'] && allDebts.docs[x].data()['owerId'] == element['owerId']) {\n            found = true;\n            var newDebt = parseFloat(allDebts.docs[x].data()['total']) + parseFloat(element['total']);\n            var newData = {\n              total: newDebt\n            };\n            var debtRef = doc(debtCollection, allDebts.docs[x].id);\n            updateDoc(debtRef, newData);\n            break;\n          } else if (allDebts.docs[x].data()['owerId'] == element['lenderId'] && allDebts.docs[x].data()['lenderId'] == element['owerId']) {\n            found = true;\n            var newDebt = (parseFloat(allDebts.docs[x].data()['total']) + parseFloat(element['total']) * -1).toFixed(2);\n            if (newDebt == 0.0) {\n              var _debtRef = yield doc(debtCollection, allDebts.docs[x].id);\n              yield deleteDoc(_debtRef);\n            } else if (newDebt < 0.0) {\n              newDebt *= -1;\n              var newData = {\n                owerId: allDebts.docs[x].data()['lenderId'],\n                lenderId: allDebts.docs[x].data()['owerId'],\n                total: newDebt\n              };\n              var _debtRef2 = yield doc(debtCollection, allDebts.docs[x].id);\n              yield updateDoc(_debtRef2, newData);\n            } else {\n              var newData = {\n                total: newDebt\n              };\n              var _debtRef3 = yield doc(debtCollection, allDebts.docs[x].id);\n              yield updateDoc(_debtRef3, newData);\n            }\n            break;\n          }\n        }\n        if (!found) {\n          console.log('Added debt');\n          var _debt = yield addDoc(debtCollection, element);\n        }\n      });\n      return function (_x20) {\n        return _ref2.apply(this, arguments);\n      };\n    }()));\n  });\n  return _createTransaction.apply(this, arguments);\n}\nexport function getUserId(_x9) {\n  return _getUserId.apply(this, arguments);\n}\nfunction _getUserId() {\n  _getUserId = _asyncToGenerator(function* (authId) {\n    console.log(authId);\n    var q = query(userCollection, where(\"uid\", \"==\", authId));\n    var user = yield getDocs(q);\n    return user.docs[0].id;\n  });\n  return _getUserId.apply(this, arguments);\n}\nexport function getGroups(_x10) {\n  return _getGroups.apply(this, arguments);\n}\nfunction _getGroups() {\n  _getGroups = _asyncToGenerator(function* (userId) {\n    var groupData = [];\n    var userRef = doc(userCollection, userId);\n    var userDoc = yield getDoc(userRef);\n    var groups = userDoc.data()['groups'];\n    var groupIds = Object.keys(groups);\n    for (var x = 0; x < groupIds.length; x++) {\n      var groupRef = doc(groupCollection, groupIds.at(x));\n      var groupDoc = yield getDoc(groupRef);\n      groupData.push(_objectSpread(_objectSpread({}, groupDoc.data()), {}, {\n        id: groupDoc.id\n      }));\n    }\n    return groupData;\n  });\n  return _getGroups.apply(this, arguments);\n}\nexport function getGroupUsers(_x11) {\n  return _getGroupUsers.apply(this, arguments);\n}\nfunction _getGroupUsers() {\n  _getGroupUsers = _asyncToGenerator(function* (groupId) {\n    var userData = [];\n    var groupRef = doc(groupCollection, groupId);\n    var groupDoc = yield getDoc(groupRef);\n    var users = groupDoc.data()['users'];\n    var userIds = Object.keys(users);\n    for (var x = 0; x < userIds.length; x++) {\n      console.log(userIds.at(x));\n      var userRef = doc(userCollection, userIds.at(x));\n      var userDoc = yield getDoc(userRef);\n      userData.push(_objectSpread(_objectSpread({}, userDoc.data()), {}, {\n        id: userDoc.id\n      }));\n    }\n    return userData;\n  });\n  return _getGroupUsers.apply(this, arguments);\n}\nexport function createGroup(_x12, _x13, _x14) {\n  return _createGroup.apply(this, arguments);\n}\nfunction _createGroup() {\n  _createGroup = _asyncToGenerator(function* (addedUsers, userId, groupName) {\n    var users = {};\n    var groupId;\n    addedUsers.push(userId);\n    var startingData = {\n      name: groupName,\n      total: 0.00,\n      passcode: generateRandomPasscode()\n    };\n    var r = yield addDoc(groupCollection, startingData).then(function (docRef) {\n      groupId = docRef.id;\n    }).catch(function (error) {\n      console.log(error);\n    });\n    console.log(groupId);\n    for (var i = 0; i < addedUsers.length; i++) {\n      var id = addedUsers[i];\n      users[id] = true;\n      var userRef = doc(userCollection, id);\n      var userDoc = yield getDoc(userRef);\n      if (!userDoc.exists) {\n        console.log('Not a user!');\n      } else {\n        var groups = userDoc.data()['groups'];\n        groups[groupId] = true;\n        updateDoc(userRef, {\n          groups: groups\n        });\n      }\n    }\n    var data = {\n      users: users\n    };\n    var groupRef = doc(groupCollection, groupId);\n    var res = yield updateDoc(groupRef, data);\n  });\n  return _createGroup.apply(this, arguments);\n}\nexport function updateGroupMembers(_x15) {\n  return _updateGroupMembers.apply(this, arguments);\n}\nfunction _updateGroupMembers() {\n  _updateGroupMembers = _asyncToGenerator(function* (newUsers) {\n    var gId = \"qRj9iF0OMLCTpvSbD9Ep\";\n    var users;\n    var groupRef = doc(groupCollection, gId);\n    var docSnap = yield getDoc(groupRef);\n    if (!docSnap.exists) {\n      console.log('No such document!');\n    } else {\n      console.log('Document data:', docSnap.data());\n      users = docSnap.data()['users'];\n    }\n    for (var i = 0; i < newUsers.length; i++) {\n      users[newUsers[i]] = true;\n    }\n    updateDoc(groupRef, {\n      users: users\n    });\n  });\n  return _updateGroupMembers.apply(this, arguments);\n}\nexport function joinGroup(_x16, _x17) {\n  return _joinGroup.apply(this, arguments);\n}\nfunction _joinGroup() {\n  _joinGroup = _asyncToGenerator(function* (passcode, userId) {\n    var group = query(groupCollection, where('passcode', '==', passcode));\n    var querySnapshot = yield getDocs(group);\n    var groups;\n    if (querySnapshot.size > 0) {\n      var users = querySnapshot.docs[0].data()['users'];\n      console.log(users);\n      if (isInGroup(users, userId)) {\n        console.log(\"You are already in the group!\");\n        return 0;\n      }\n      var groupId = querySnapshot.docs[0].id;\n      var userRef = doc(userCollection, userId);\n      var userDoc = yield getDoc(userRef);\n      if (!userDoc.exists) {\n        console.log('No group');\n      } else {\n        console.log(userDoc.data());\n        groups = userDoc.data()['groups'];\n        groups[groupId] = true;\n        updateDoc(userRef, {\n          groups: groups\n        });\n      }\n      var groupRef = doc(groupCollection, groupId);\n      users[userId] = true;\n      var response = yield updateDoc(groupRef, {\n        users: users\n      });\n      console.log(\"Added to the group!\");\n      return 1;\n    } else {\n      console.log(\"No group found!\");\n    }\n  });\n  return _joinGroup.apply(this, arguments);\n}\nexport function getAllUsers() {\n  return _getAllUsers.apply(this, arguments);\n}\nfunction _getAllUsers() {\n  _getAllUsers = _asyncToGenerator(function* () {\n    var users = yield getDocs(userCollection);\n    var userData = [];\n    users.forEach(function (doc) {\n      userData.push(_objectSpread(_objectSpread({}, doc.data()), {}, {\n        id: doc.id\n      }));\n    });\n    console.log(userData);\n    return userData;\n  });\n  return _getAllUsers.apply(this, arguments);\n}\nexport function getUser(_x18) {\n  return _getUser.apply(this, arguments);\n}\nfunction _getUser() {\n  _getUser = _asyncToGenerator(function* (queryData) {\n    var queryChoice = 'name';\n    var userRef = query(userCollection, where(queryChoice, '==', queryData));\n    var userDoc = yield getDocs(userRef);\n    if (userDoc.size > 0) {\n      var data = _objectSpread(_objectSpread({}, userDoc.docs[0].data()), {}, {\n        id: userDoc.docs[0].id\n      });\n      console.log(data);\n      return data;\n    } else {\n      console.log(\"User doesn't exist\");\n      return 0;\n    }\n  });\n  return _getUser.apply(this, arguments);\n}\nfunction isInGroup(users, userId) {\n  var userIds = Object.keys(users);\n  console.log(userIds);\n  for (var x = 0; x < userIds.length; x++) {\n    if (userIds[x] == userId) {\n      console.log(userIds[x]);\n      return true;\n    }\n  }\n  return false;\n}\nexport function generateRandomPasscode() {\n  var passcode = '';\n  var string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz0123456789@#$';\n  for (var i = 1; i <= passcodeLength; i++) {\n    var char = Math.floor(Math.random() * string.length + 1);\n    passcode += string.charAt(char);\n  }\n  return passcode;\n}","map":{"version":3,"names":["db","getFirestore","doc","addDoc","collection","deleteDoc","setDoc","query","getDocs","getDoc","orderBy","limit","get","where","updateDoc","getUsers","transactionCollection","groupCollection","debtCollection","userCollection","passcodeLength","GetGroupDebts","_x","_GetGroupDebts","apply","arguments","_asyncToGenerator","groupId","debtList","q","querySnapshot","forEach","_ref","owerName","find","user","id","data","name","lenderName","push","_objectSpread","_x19","GetGroupData","_x2","_GetGroupData","docRef","groupData","docSnap","exists","console","log","error","GetGroupTransactions","_x3","_GetGroupTransactions","transactionList","createTransaction","_x4","_x5","_x6","_x7","_x8","_createTransaction","transactionName","transactionTotal","debts","currentGroupTotal","groupRef","newTotal","parseFloat","toFixed","updatedGroupData","total","transaction","allDebts","Promise","all","map","_ref2","element","found","size","debt","x","docs","newDebt","newData","debtRef","owerId","lenderId","_x20","getUserId","_x9","_getUserId","authId","getGroups","_x10","_getGroups","userId","userRef","userDoc","groups","groupIds","Object","keys","length","at","groupDoc","getGroupUsers","_x11","_getGroupUsers","userData","users","userIds","createGroup","_x12","_x13","_x14","_createGroup","addedUsers","groupName","startingData","passcode","generateRandomPasscode","r","then","catch","i","res","updateGroupMembers","_x15","_updateGroupMembers","newUsers","gId","joinGroup","_x16","_x17","_joinGroup","group","isInGroup","response","getAllUsers","_getAllUsers","getUser","_x18","_getUser","queryData","queryChoice","string","char","Math","floor","random","charAt"],"sources":["D:/Work/Projects/Split/Split/backendFiles/firebaseFunctions.js"],"sourcesContent":["import { db } from \"../config/firebase\";\r\nimport {getFirestore,doc,addDoc,collection,deleteDoc,setDoc,query,getDocs,getDoc,orderBy,limit,get,where, updateDoc} from 'firebase/firestore';\r\nimport {getUsers} from'../AppData'\r\nconst transactionCollection = collection(db,'transaction');\r\nconst groupCollection = collection(db,'group');\r\nconst debtCollection = collection(db,'debt');\r\nconst userCollection = collection(db,'user');\r\n\r\nconst passcodeLength = 5;\r\n//How to add extra fields to a map: Example\r\n//debtList.push({...doc.data(), lenderName: lenderName,owerName:owerName});\r\n\r\n\r\n// I get all the debts associated with the groupId, and order the documents by the total in descending order.\r\nexport async function GetGroupDebts(groupId){\r\n    var debtList = [];\r\n    const q = query(debtCollection, where(\"groupId\", \"==\", groupId), orderBy(\"total\",\"desc\"));\r\n    const querySnapshot = await getDocs(q);\r\n    querySnapshot.forEach(async (doc) => {\r\n        //have the users data stored, can find their name based on the id retrieved\r\n        var owerName = getUsers().find(user => user.id === doc.data()['owerId']).name;\r\n        var lenderName = getUsers().find(user => user.id === doc.data()['lenderId']).name;\r\n\r\n        debtList.push({...doc.data(),id:doc.id, owerName:owerName, lenderName:lenderName});\r\n    });\r\n    return debtList;\r\n}\r\n\r\n//I get the document that is associated with the groupId\r\nexport async function GetGroupData(groupId){\r\n    const docRef = doc(groupCollection, groupId);\r\n    var groupData;\r\n    try {\r\n        const docSnap = await getDoc(docRef);\r\n        if(docSnap.exists()) {\r\n            groupData = docSnap.data();\r\n            console.log(groupData);\r\n        } else {\r\n            console.log(\"Group does not exist\")\r\n        }\r\n    } catch(error) {\r\n        console.log(error)\r\n    }\r\n    return groupData;\r\n  }\r\n  export async function GetGroupTransactions(groupId){\r\n    var transactionList = [];\r\n    // console.log(\"Firebase:\" + groupId);\r\n    const q = query(transactionCollection, where(\"groupId\", \"==\", groupId));\r\n    const querySnapshot = await getDocs(q);\r\n    // console.log(querySnapshot);\r\n    querySnapshot.forEach((doc) => {\r\n        console.log(doc.id, \" => \", doc.data());\r\n        transactionList.push(doc.data());\r\n    });\r\n    return transactionList;\r\n  }\r\n  export async function createTransaction(transactionName,transactionTotal,groupId,debts,currentGroupTotal){\r\n    //Update the total expense in the group document\r\n    const groupRef = doc(groupCollection,groupId);\r\n    var newTotal = (parseFloat(currentGroupTotal) + parseFloat(transactionTotal)).toFixed(2);\r\n    var updatedGroupData = {\r\n        total:parseFloat(newTotal)\r\n    }\r\n\r\n    await updateDoc(groupRef,updatedGroupData);\r\n\r\n    var data = {\r\n      name:transactionName,\r\n      total:transactionTotal,\r\n      groupId:groupId,\r\n    }\r\n\r\n    const transaction = await addDoc(transactionCollection, data);\r\n    //accessing the list of debts\r\n    console.log(debts);\r\n    //Debts are added\r\n    const q = query(debtCollection, where(\"groupId\", \"==\", groupId));\r\n   const allDebts = await getDocs(q);\r\n\r\n\r\n   await Promise.all(debts.map(async (element) => {\r\n     //no debts yet, just add the debt\r\n     var found = false;\r\n     if(allDebts.size<=0){\r\n       console.log('Added debt');\r\n       const debt = await addDoc(debtCollection, element);\r\n       found = true;   \r\n     }\r\n     for(var x = 0;x<allDebts.size;x++){\r\n       //matches current so the ower will need to owe more\r\n       //take the current debt and add the extra debt\r\n       console.log(allDebts.docs[x].data());\r\n       if(allDebts.docs[x].data()['lenderId'] == element['lenderId'] && allDebts.docs[x].data()['owerId'] == element['owerId']){\r\n         found = true;\r\n         var newDebt = parseFloat(allDebts.docs[x].data()['total']) + parseFloat(element['total']);\r\n         var newData = {\r\n           total:newDebt,\r\n         }\r\n         const debtRef = doc(debtCollection,allDebts.docs[x].id);\r\n         updateDoc(debtRef,newData);\r\n         break;\r\n       }\r\n       //reversed so the ower will owe less, may pay off or need to be owed now\r\n       else if(allDebts.docs[x].data()['owerId'] == element['lenderId'] && allDebts.docs[x].data()['lenderId'] == element['owerId']){\r\n        found = true;\r\n         var newDebt = (parseFloat(allDebts.docs[x].data()['total']) + (parseFloat(element['total'])*-1)).toFixed(2);\r\n         //delete the debt\r\n         if(newDebt==0.0){\r\n           const debtRef = await doc(debtCollection,allDebts.docs[x].id);\r\n           await deleteDoc(debtRef);\r\n         }\r\n         //reverse the debt\r\n         else if(newDebt<0.0){\r\n           //change debt to positive\r\n           newDebt*=-1;\r\n           //swith lender and owerId\r\n           var newData = {\r\n             owerId:allDebts.docs[x].data()['lenderId'],\r\n             lenderId:allDebts.docs[x].data()['owerId'],\r\n             total:newDebt,\r\n           }\r\n           //update the doc with the new data\r\n           const debtRef = await doc(debtCollection,allDebts.docs[x].id);\r\n           await updateDoc(debtRef,newData);\r\n         }\r\n         else{\r\n           var newData = {\r\n             total:newDebt,\r\n           }\r\n           //only update the total\r\n           const debtRef = await doc(debtCollection,allDebts.docs[x].id);\r\n           await updateDoc(debtRef,newData);\r\n         }\r\n         break;\r\n       }\r\n     }\r\n     if(!found){\r\n      //no doc matching add debt\r\n      console.log('Added debt');\r\n      const debt = await addDoc(debtCollection, element);\r\n     }\r\n   }));\r\n  }\r\n\r\n  export async function getUserId(authId){\r\n    console.log(authId);\r\n    const q = query(userCollection, where(\"uid\", \"==\", authId));\r\n    const user= await getDocs(q);\r\n    return user.docs[0].id;\r\n  }\r\n\r\n\r\n  export async function getGroups(userId) {\r\n    var groupData = [];\r\n    const userRef = doc(userCollection,userId);\r\n    const userDoc = await getDoc(userRef);\r\n    //get the users groups\r\n    var groups = userDoc.data()['groups'];\r\n    //putting the ids into a list\r\n    var groupIds = Object.keys(groups);\r\n    //push the data from each group document\r\n    for(var x = 0;x<groupIds.length;x++){\r\n      const groupRef = doc(groupCollection,groupIds.at(x));\r\n      const groupDoc = await getDoc(groupRef);\r\n      //id is added to the data so that it can be used as a key\r\n      //so transactions can be accessed\r\n      groupData.push({...groupDoc.data(), id: groupDoc.id});\r\n    }\r\n    return groupData;\r\n  }\r\n  export async function getGroupUsers(groupId) {\r\n    var userData = [];\r\n    const groupRef = doc(groupCollection,groupId);\r\n    //get the document\r\n    const groupDoc = await getDoc(groupRef);\r\n    var users = groupDoc.data()['users'];\r\n    let userIds = Object.keys(users);\r\n    //check if the id passed matches something already in\r\n    for(var x = 0;x<userIds.length;x++){\r\n      console.log(userIds.at(x));\r\n      const userRef = doc(userCollection,userIds.at(x));\r\n      const userDoc = await getDoc(userRef);\r\n      //id also added to data\r\n      userData.push({...userDoc.data(), id: userDoc.id});\r\n    }\r\n    return userData;\r\n  }\r\n  export async function createGroup(addedUsers,userId,groupName) {\r\n    var users = {};\r\n    var groupId;\r\n    //adding self to group as well\r\n    addedUsers.push(userId);\r\n    const startingData ={\r\n      name:groupName,\r\n      total:0.00,\r\n      passcode: generateRandomPasscode(),\r\n    }\r\n    const r = await addDoc(groupCollection, startingData)\r\n    .then(docRef => {\r\n      groupId = docRef.id;\r\n      // console.log(groupId);\r\n    })\r\n    .catch(error => {\r\n      console.log(error);\r\n    })\r\n    console.log(groupId);\r\n    for(var i = 0;i < addedUsers.length;i++){\r\n      var id = addedUsers[i];\r\n      users[id] = true;\r\n      //reference to the user\r\n      const userRef = doc(userCollection,id);\r\n      //get the document\r\n      const userDoc = await getDoc(userRef);\r\n      if (!userDoc.exists) {\r\n        console.log('Not a user!');\r\n      } else {\r\n        var groups = userDoc.data()['groups'];\r\n        groups[groupId] = true;\r\n        //updating the users document\r\n        updateDoc(userRef,{groups});\r\n      }\r\n    }\r\n    const data ={\r\n      users\r\n    }\r\n    //group updated\r\n    var groupRef = doc(groupCollection,groupId);\r\n    const res = await updateDoc(groupRef,data);\r\n  }\r\n  //This function may not be needed depending on if you can add members\r\n  //after creating a group or if the only way they can join is through the code\r\n  export async function updateGroupMembers(newUsers){\r\n    var gId = \"qRj9iF0OMLCTpvSbD9Ep\";\r\n    var users;\r\n    const groupRef = doc(groupCollection,gId);\r\n    const docSnap = await getDoc(groupRef);\r\n    if (!docSnap.exists) {\r\n        console.log('No such document!');\r\n    } else {\r\n        console.log('Document data:', docSnap.data());\r\n        users = docSnap.data()['users'];\r\n    }\r\n    //adding multiple new users\r\n    for(var i = 0;i<newUsers.length;i++){\r\n      users[newUsers[i]]=true;\r\n    }\r\n    updateDoc(groupRef,{\r\n      users\r\n    })\r\n  }\r\n  //can have a alert\r\n  //check for return value if 1, write joined group\r\n  //if 0, write you are already in the group\r\n  export async function joinGroup(passcode,userId) {\r\n    //query to find the group with the passcode\r\n    const group = query(groupCollection, where('passcode', '==', passcode));\r\n    const querySnapshot = await getDocs(group);\r\n    var groups;\r\n    //group was found\r\n    if (querySnapshot.size>0) {\r\n      //getting the groups users\r\n      var users = querySnapshot.docs[0].data()['users'];\r\n      console.log(users);\r\n      if(isInGroup(users,userId)){\r\n        console.log(\"You are already in the group!\");\r\n        return 0;\r\n      }\r\n      //Adding the group to the user's list\r\n      //the groups id\r\n      const groupId = querySnapshot.docs[0].id;\r\n      //reference to the user\r\n      const userRef = doc(userCollection,userId);\r\n      //get the document\r\n      const userDoc = await getDoc(userRef);\r\n      if (!userDoc.exists) {\r\n        console.log('No group');\r\n      } else {\r\n        //this is the users group list\r\n        console.log(userDoc.data());\r\n        groups = userDoc.data()['groups'];\r\n        //adding the group\r\n        groups[groupId]=true;\r\n        //updating the users document\r\n        updateDoc(userRef,{\r\n          groups\r\n        })\r\n      }\r\n      //Adding the user to the group's list\r\n      //getting a reference to the group\r\n      const groupRef = doc(groupCollection,groupId);\r\n      //adding the user to the group\r\n      users[userId]=true;\r\n      //updating the document\r\n      const response = await updateDoc(groupRef,{\r\n        users\r\n      })\r\n      console.log(\"Added to the group!\");\r\n      return 1;\r\n    //no documents\r\n    } else {\r\n      console.log(\"No group found!\");\r\n    }\r\n  }\r\n  //finds all users in the database\r\n  export async function getAllUsers(){\r\n    //gets every thing in the user collection\r\n    const users = await getDocs(userCollection);\r\n    const userData = [];\r\n    users.forEach(doc => {\r\n      //pushes data including id to the list\r\n      userData.push({...doc.data(), id: doc.id});\r\n    })\r\n    console.log(userData);\r\n    return userData;\r\n  }\r\n  //finds one user in data base if found returns data otherwise returns 0\r\n  export async function getUser(queryData){\r\n    const queryChoice='name'\r\n    //tries to find the document based on a query in this case the name\r\n    const userRef = query(userCollection, where(queryChoice, '==', queryData));\r\n    const userDoc = await getDocs(userRef);\r\n    if (userDoc.size > 0) {\r\n      const data = {...userDoc.docs[0].data(), id:userDoc.docs[0].id};\r\n      console.log(data);\r\n      return data;\r\n    } else {\r\n      console.log(\"User doesn't exist\");\r\n      return 0;\r\n    }\r\n  }\r\n  function isInGroup(users,userId){\r\n    //gives only the ids\r\n    let userIds = Object.keys(users);\r\n    console.log(userIds);\r\n    //check if the id passed matches something already in\r\n    for(var x = 0;x<userIds.length;x++){\r\n      if(userIds[x]==userId){\r\n        console.log(userIds[x]);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  //Resource:https://www.geeksforgeeks.org/how-to-generate-a-random-password-using-javascript/\r\n  export function generateRandomPasscode(){\r\n      var passcode = '';\r\n      var string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\r\n              'abcdefghijklmnopqrstuvwxyz0123456789@#$';\r\n      for (let i = 1; i <= passcodeLength; i++) {\r\n          var char = Math.floor(Math.random()\r\n                      * string.length + 1);\r\n          passcode += string.charAt(char)\r\n      }\r\n      return passcode;\r\n  }\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}